{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"udvm documentation","text":"<p>Her kan du l\u00e6se om udvalgte funktioner fra bla.a \"DBI-egenkontrol\" projektet samt tests, kodeprincipper og Git.</p>"},{"location":"#om","title":"Om","text":"<p>Vi er to passionerede webudviklere med fokus p\u00e5 frontend programmering</p>"},{"location":"#udviklere","title":"Udviklere","text":"<ul> <li>Carina</li> <li>(Sebastian) &lt;- makker p\u00e5 DBI projekt</li> </ul>"},{"location":"git/","title":"Git workflow","text":""},{"location":"git/#branch-strategi","title":"Branch strategi","text":"<p>I DBI projektet brugte vi en \"developer branch\" strategi, hvor hvert gruppemedlem arbejdede p\u00e5 samme developer branch som til sidst blev merget med main/master.</p>"},{"location":"git/#branch-struktur","title":"Branch struktur","text":"<pre><code>Main/master \n\u251c\u2500\u2500 Developer branch\n\u2514\u2500\u2500 Feature branch\n</code></pre> <p>Selvom at vi begge arbejdede p\u00e5 den samme developer branch var vi obs p\u00e5 at undg\u00e5 konflikter s\u00e5 vidt muligt. Dette gjorde vi ved ikke at arbejde p\u00e5 de samme views samtidig.</p>"},{"location":"git/#commits","title":"Commits","text":"<p>Et commit betyder at du gemmer en version af projektet med en besked, der forklarer, hvad du har \u00e6ndret. Hellere sm\u00e5 men regelm\u00e6ssige commits end f\u00e5 st\u00f8rre commits.</p>"},{"location":"git/#hvorfor","title":"Hvorfor","text":"<ul> <li> <p>Man mister ikke sine \u00e6ndringer, hvis noget g\u00e5r galt.</p> </li> <li> <p>Mindre commits g\u00f8r det nemt at se, hvorn\u00e5r en fejl opst\u00e5r.</p> </li> <li> <p>Andre kan nemt se, hvad man har lavet, og hvorfor.</p> </li> <li> <p>Hvis noget g\u00e5r galt, kan man nemt g\u00e5 tilbage til en tidligere version.</p> </li> </ul>"},{"location":"git/#darlige-eksempler-pa-commits","title":"D\u00e5rlige eksempler p\u00e5 commits","text":"<p><pre><code> \"tilf\u00f8jet \u00e6ndringer\"\n \"fikset fejl\"\n \"opdateret \u00e6ndringer\"\n \"asdf\"\n \"rettet login fejl\"\n</code></pre> ^^siger intet om hvad der er \u00e6ndret</p> <p>^^hj\u00e6lper ikke andre personer med at forst\u00e5 hvad der er lavet.</p>"},{"location":"git/#gode-eksempler-pa-commits","title":"Gode eksempler p\u00e5 commits","text":"<p><pre><code> \"Ret fejl hvor login fejlede med korrekt adgangskode\"\n \"Tilf\u00f8j s\u00f8gefunktion til brugerliste\"\n \"Opdat\u00e9r README med installationsvejledning\"\n \"Fjern ubrugte import fra TemplatePage.vue\"\n</code></pre> ^^Det beskriver tydeligt hvad der er \u00e6ndret</p> <p>^^Giver andre en klar forst\u00e5else for \u00e6ndringerne i \"projektet\"</p>"},{"location":"git/#github-actions","title":"Github actions","text":"<p>GitHub Actions bruges til CI/CD til automatisk at bygge og publicere dokumentationen.</p> <pre><code>name: Deploy MkDocs to GitHub Pages\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.x'\n\n      - name: Install MkDocs and Material theme\n        run: pip install mkdocs mkdocs-material\n\n\n      - name: Deploy to GitHub Pages\n        run: mkdocs gh-deploy --force\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <ul> <li>Workflowet k\u00f8rer automatisk, hver gang man pusher til main</li> </ul>"},{"location":"static-codeanalysis/","title":"Statisk kode analyse","text":""},{"location":"static-codeanalysis/#eslint","title":"ESLint","text":"<p>ESLint er et statisk kodeanalysev\u00e6rkt\u00f8j der kan bruges til at analysere kode. </p> <p>Her b\u00e5de l\u00e6ser og gennemg\u00e5r ESLint koden,  for at finde fejl f\u00f8r koden bliver eksekveret.</p>"},{"location":"static-codeanalysis/#hvorfor-bruge-eslint","title":"Hvorfor bruge ESLint","text":"<ul> <li> <p>Fordi den sikrer, at hele teamet f\u00f8lger de samme kodestandarder og konventioner ved at alle medlemmer har ensartet kode.</p> </li> <li> <p>Den finder syntaksfejl, bugs og d\u00e5rlige kodestile, f\u00f8r koden k\u00f8res eller deployes.</p> </li> <li> <p>Den g\u00f8r koden lettere at l\u00e6se og vedligeholde fremadrettet.</p> </li> <li> <p>Den kan integreres i CI/CD pipelines, s\u00e5 kode automatisk tjekkes ved hver commit.</p> </li> </ul>"},{"location":"static-codeanalysis/#eksempel","title":"Eksempel","text":"<pre><code>rules: {\n    'comma-dangle': ['error', 'always-multiline'],\n    'eqeqeq': ['error', 'always'],\n    'indent': ['error', 2],\n    'no-eval': ['error'],\n    'no-trailing-spaces': ['error'],\n    'no-unused-vars': ['error'],\n    'no-var': ['error'],\n    'prefer-const': ['error'],\n    'quotes': ['error', 'single'],\n    'semi': ['error', 'always'],\n  },\n</code></pre>"},{"location":"static-codeanalysis/#refaktoring","title":"Refaktoring","text":"<p>Refaktoring er processen, hvor man \u00e6ndrer koden internt for at forbedre dens struktur, uden at \u00e6ndre dens eksterne opf\u00f8rsel. </p>"},{"location":"static-codeanalysis/#hvorfor-bruge-refaktoring","title":"Hvorfor bruge refaktoring","text":"<ul> <li> <p>G\u00f8r det lettere for andre og dig selv at forst\u00e5 koden.</p> </li> <li> <p>G\u00f8r koden mindre kompleks og nemmere at teste.</p> </li> <li> <p>G\u00f8r det lettere at tilf\u00f8je nye funktioner senere.</p> </li> <li> <p>Fjerner \"hurtige l\u00f8sninger\" og d\u00e5rlige m\u00f8nstre.</p> </li> </ul>"},{"location":"static-codeanalysis/#eksempel_1","title":"Eksempel","text":"<p>Kode f\u00f8r brug af refaktoring <pre><code>const sortBy = ref('none');\n\nconst sortedTemplates = computed(() =&gt; {\n  let arr = [...templates.value];\n  if (sortBy.value === 'newest') {\n    arr.sort((a, b) =&gt; parseDate(b.date) - parseDate(a.date));\n  } else if (sortBy.value === 'oldest') {\n    arr.sort((a, b) =&gt; parseDate(a.date) - parseDate(b.date));\n  } else if (sortBy.value === 'mostUsed') {\n    arr.sort((a, b) =&gt; b.uses - a.uses);\n  }\n  return arr;\n});\n</code></pre> ^^ Hver sorteringsregel kr\u00e6ver et nyt if eller else if-statement.</p> <p>^^ Hvis man vil tilf\u00f8je en ny sorteringsmetode, skal man tilf\u00f8je endnu en else if-blok.</p> <p>^^ Koden bliver hurtigt lang og sv\u00e6r at l\u00e6se, hvis der kommer flere sorteringsmuligheder.</p>"},{"location":"static-codeanalysis/#eksempel_2","title":"Eksempel","text":"<p>Kode efter brug af refaktoring <pre><code>const sortBy = ref('none');\n\nconst sortFunctions = {\n  newest: (a, b) =&gt; parseDate(b.date) - parseDate(a.date),\n  oldest: (a, b) =&gt; parseDate(a.date) - parseDate(b.date),\n  mostUsed: (a, b) =&gt; b.uses - a.uses,\n  none: () =&gt; 0, // Ingen sortering\n};\n\nconst sortedTemplates = computed(() =&gt; {\n  const arr = [...templates.value];\n  const sortFn = sortFunctions[sortBy.value] || sortFunctions.none;\n  return arr.sort(sortFn);\n});\n</code></pre> ^^ Alle sorteringsfunktioner er samlet \u00e9t sted.</p> <p>^^ Det er nemt at se, hvilke sorteringer der findes, og hvordan de fungerer.</p> <p>^^ Hvis man vil tilf\u00f8je en ny sortering, skal man kun tilf\u00f8je en ny funktion til sortFunctions-objektet.</p> <p>^^ Man beh\u00f8ver ikke \u00e6ndre selve sorteringskoden eller tilf\u00f8je flere if-statements.</p> <p>^^ Man kalder kun arr.sort(...) \u00e9n gang, uanset hvilken sortering der v\u00e6lges.</p>"},{"location":"static-codeanalysis/#principper","title":"Principper","text":"<ul> <li> <p>Lav sm\u00e5, sikre \u00e6ndringer, og test ofte.</p> </li> <li> <p>Koden skal virke p\u00e5 samme m\u00e5de f\u00f8r og efter refaktoring.</p> </li> <li> <p>Brug tests til at sikre, at du ikke har \u00f8delagt noget.</p> </li> </ul>"},{"location":"static-codeanalysis/#eksempler-pa-kode-principper-at-flge","title":"Eksempler p\u00e5 kode principper at f\u00f8lge:","text":"<ul> <li> <p>DRY (dont repeat yourself) ^^Undg\u00e5 at have den samme kode flere steder</p> </li> <li> <p>KISS (keep it simple, stupid) ^^Hold det enkelt og overskueligt s\u00e5 det er nemt at vedligeholde</p> </li> <li> <p>SRP (single responsibility principle) ^^\u00c8n klasse eller funktion til \u00e9t ansvar</p> </li> <li> <p>YAGNI (you aren't gonna need it) ^^Hold fokus p\u00e5 det mest n\u00f8dvendige</p> </li> </ul>"},{"location":"tests/","title":"Unit tests","text":""},{"location":"tests/#hvorfor","title":"Hvorfor","text":"<ul> <li> <p>Man opdager hurtigt, hvis en funktion ikke g\u00f8r det, den skal.</p> </li> <li> <p>Man kan v\u00e6re sikker p\u00e5, at ens kode virker, som man forventer.</p> </li> <li> <p>Hvis man \u00e6ndrer noget, kan man hurtigt se, om det har \u00f8delagt noget andet.</p> </li> <li> <p>Den viser hvordan en funktion skal bruges, og hvad den skal returnere.</p> </li> </ul>"},{"location":"tests/#sortfiles","title":"sortFiles","text":"<p>Denne funktion blev brugt til at sortere en liste af filer efter dato, (nyeste, \u00e6ldste, mest brugte og ingen)</p> FunktionTestTest-outputAnvendelse <pre><code>function parseDate(dateStr) {\n  return new Date(dateStr);\n}\n\nexport function sortFiles(files, sortBy) {\n  let arr = [...files];\n  if (sortBy === 'newest') {\n    arr.sort((a, b) =&gt; parseDate(b.date) - parseDate(a.date));\n  } else if (sortBy === 'oldest') {\n    arr.sort((a, b) =&gt; parseDate(a.date) - parseDate(b.date));\n  } else if (sortBy === 'mostUsed') {\n    arr.sort((a, b) =&gt; b.uses - a.uses);\n  }\n  return arr;\n}\n</code></pre> <pre><code>import { sortFiles } from './sortFiles';\n\nconst files = [\n  { name: 'A', date: '2024-01-01', uses: 5 },\n  { name: 'B', date: '2024-05-01', uses: 2 },\n  { name: 'C', date: '2023-12-01', uses: 10 },\n];\n\ndescribe('sortFiles', () =&gt; {\n  test('sorts by newest', () =&gt; {\n    const sorted = sortFiles(files, 'newest');\n    expect(sorted[0].name).toBe('B');\n    expect(sorted[1].name).toBe('A');\n    expect(sorted[2].name).toBe('C');\n  });\n\n  test('sorts by oldest', () =&gt; {\n    const sorted = sortFiles(files, 'oldest');\n    expect(sorted[0].name).toBe('C');\n    expect(sorted[1].name).toBe('A');\n    expect(sorted[2].name).toBe('B');\n  });\n\n  test('sorts by mostUsed', () =&gt; {\n    const sorted = sortFiles(files, 'mostUsed');\n    expect(sorted[0].name).toBe('C');\n    expect(sorted[1].name).toBe('A');\n    expect(sorted[2].name).toBe('B');\n  });\n});\n</code></pre> <pre><code>PASS  sortFiles.test.js\n  sortFiles\n    \u2713 sorts by newest (3 ms)\n    \u2713 sorts by oldest\n    \u2713 sorts by mostUsed\n\nTest Suites: 1 passed, 1 total\nTests:       3 passed, 3 total\n</code></pre> <pre><code>const files = [\n  { name: 'A', date: '2024-01-01', uses: 5 },\n  { name: 'B', date: '2024-05-01', uses: 2 },\n  { name: 'C', date: '2023-12-01', uses: 10 },\n];\n\nsortFiles(files, 'newest');\n// =&gt; [ { name: 'B', ... }, { name: 'A', ... }, { name: 'C', ... } ]\n\nsortFiles(files, 'oldest');\n// =&gt; [ { name: 'C', ... }, { name: 'A', ... }, { name: 'B', ... } ]\n\nsortFiles(files, 'mostUsed');\n// =&gt; [ { name: 'C', ... }, { name: 'A', ... }, { name: 'B', ... } ]\n</code></pre>"},{"location":"tests/#parsedate","title":"parseDate","text":"<p>Denne funktion konverterede en dato-streng p\u00e5 formatet <code>dd/mm/yyyy</code> til et JavaScript <code>Date</code>-objekt.</p> FunktionTestTest-outputAnvendelse <pre><code>function parseDate(str) {\n  const [day, month, year] = str.split('/').map(Number);\n  return new Date(year, month - 1, day);\n}\n</code></pre> <pre><code>import { parseDate } from './parseDate';\n\ndescribe('parseDate', () =&gt; {\n  test('konverterer \"28/05/2025\" korrekt', () =&gt; {\n    const date = parseDate('28/05/2025');\n    expect(date.getFullYear()).toBe(2025);\n    expect(date.getMonth()).toBe(4); \n    expect(date.getDate()).toBe(28);\n  });\n\n  test('konverterer \"01/01/2000\" korrekt', () =&gt; {\n    const date = parseDate('01/01/2000');\n    expect(date.getFullYear()).toBe(2000);\n    expect(date.getMonth()).toBe(0); \n    expect(date.getDate()).toBe(1);\n  });\n\n  test('konverterer \"31/12/1999\" korrekt', () =&gt; {\n    const date = parseDate('31/12/1999');\n    expect(date.getFullYear()).toBe(1999);\n    expect(date.getMonth()).toBe(11); \n    expect(date.getDate()).toBe(31);\n  });\n});\n</code></pre> <pre><code>PASS  parseDate.test.js\n  parseDate\n    \u2713 konverterer \"28/05/2025\" korrekt\n    \u2713 konverterer \"01/01/2000\" korrekt\n    \u2713 konverterer \"31/12/1999\" korrekt\n\nTest Suites: 1 passed, 1 total\nTests:       3 passed, 3 total\n</code></pre> <pre><code>parseDate('28/05/2025');\n\n\nparseDate('01/01/2000');\n</code></pre>"},{"location":"tests/#addquestion","title":"addQuestion","text":"<p>Denne funktion tilf\u00f8jede et nyt sp\u00f8rgsm\u00e5l til listen <code>questions</code> og s\u00f8rgede for, at hvert sp\u00f8rgsm\u00e5l fik et unikt <code>qIndex</code>.</p> FunktionTestTest-outputAnvendelse <pre><code>import { ref } from 'vue';\n\nconst qIndex = ref(1);\nconst questions = ref([{ qIndex: 1 }]);\n\nfunction addQuestion() {\n  qIndex.value += 1;\n  questions.value.push({ qIndex: qIndex.value });\n}\n</code></pre> <pre><code>import { ref } from 'vue';\n\n\nconst qIndex = ref(1);\nconst questions = ref([{ qIndex: 1 }]);\n\nfunction addQuestion() {\n  qIndex.value += 1;\n  questions.value.push({ qIndex: qIndex.value });\n}\n\ndescribe('addQuestion', () =&gt; {\n  beforeEach(() =&gt; {\n\n    qIndex.value = 1;\n    questions.value = [{ qIndex: 1 }];\n  });\n\n  test('tilf\u00f8jer et sp\u00f8rgsm\u00e5l med korrekt qIndex', () =&gt; {\n    addQuestion();\n    expect(questions.value.length).toBe(2);\n    expect(questions.value[1].qIndex).toBe(2);\n  });\n\n  test('kan tilf\u00f8je flere sp\u00f8rgsm\u00e5l med stigende qIndex', () =&gt; {\n    addQuestion();\n    addQuestion();\n    expect(questions.value.length).toBe(3);\n    expect(questions.value[2].qIndex).toBe(3);\n  });\n});\n</code></pre> <pre><code>PASS  addQuestion.test.js\n  addQuestion\n    \u2713 tilf\u00f8jer et sp\u00f8rgsm\u00e5l med korrekt qIndex\n    \u2713 kan tilf\u00f8je flere sp\u00f8rgsm\u00e5l med stigende qIndex\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\n</code></pre> <pre><code>// F\u00f8r:\nquestions.value; // [{ qIndex: 1 }]\n\naddQuestion();\n// Efter:\nquestions.value; // [{ qIndex: 1 }, { qIndex: 2 }]\n\naddQuestion();\n// Efter:\nquestions.value; // [{ qIndex: 1 }, { qIndex: 2 }, { qIndex: 3 }]\n</code></pre>"},{"location":"tests/#removequestion","title":"removeQuestion","text":"<p>Denne funktion fjernede et sp\u00f8rgsm\u00e5l fra listen <code>questions</code> baseret p\u00e5 det angivne indeks.</p> FunktionTestTest-outputAnvendelse <pre><code>import { ref } from 'vue';\n\nconst questions = ref([{ qIndex: 1 }]);\n\nfunction removeQuestion(index) {\n  questions.value.splice(index, 1);\n}\n</code></pre> <pre><code>import { ref } from 'vue';\n\n\nconst questions = ref([\n  { qIndex: 1 },\n  { qIndex: 2 },\n  { qIndex: 3 }\n]);\n\nfunction removeQuestion(index) {\n  questions.value.splice(index, 1);\n}\n\ndescribe('removeQuestion', () =&gt; {\n  beforeEach(() =&gt; {\n    questions.value = [\n      { qIndex: 1 },\n      { qIndex: 2 },\n      { qIndex: 3 }\n    ];\n  });\n\n  test('fjerner sp\u00f8rgsm\u00e5let p\u00e5 det angivne indeks', () =&gt; {\n    removeQuestion(1);\n    expect(questions.value.length).toBe(2);\n    expect(questions.value).toEqual([\n      { qIndex: 1 },\n      { qIndex: 3 }\n    ]);\n  });\n\n  test('fjerner det f\u00f8rste sp\u00f8rgsm\u00e5l', () =&gt; {\n    removeQuestion(0);\n    expect(questions.value.length).toBe(2);\n    expect(questions.value).toEqual([\n      { qIndex: 2 },\n      { qIndex: 3 }\n    ]);\n  });\n\n  test('fjerner det sidste sp\u00f8rgsm\u00e5l', () =&gt; {\n    removeQuestion(2);\n    expect(questions.value.length).toBe(2);\n    expect(questions.value).toEqual([\n      { qIndex: 1 },\n      { qIndex: 2 }\n    ]);\n  });\n});\n</code></pre> <pre><code>PASS  removeQuestion.test.js\n  removeQuestion\n    \u2713 fjerner sp\u00f8rgsm\u00e5let p\u00e5 det angivne indeks\n    \u2713 fjerner det f\u00f8rste sp\u00f8rgsm\u00e5l\n    \u2713 fjerner det sidste sp\u00f8rgsm\u00e5l\n\nTest Suites: 1 passed, 1 total\nTests:       3 passed, 3 total\n</code></pre> <pre><code>// F\u00f8r:\nquestions.value; // [{ qIndex: 1 }, { qIndex: 2 }, { qIndex: 3 }]\n\nremoveQuestion(1);\n// Efter:\nquestions.value; // [{ qIndex: 1 }, { qIndex: 3 }]\n\nremoveQuestion(0);\n// Efter:\nquestions.value; // [{ qIndex: 3 }]\n</code></pre>"},{"location":"tests/#save","title":"save","text":"<p>Denne funktion oprettede et nyt formular-objekt, gemte det asynkront med <code>addForm</code>, viste en succesbesked, og omdirigerede brugeren efter 5 sekunder. </p> FunktionTestTest-outputAnvendelse <pre><code>import { ref } from 'vue';\nimport { addForm } from './api'; \nimport { useRouter } from 'vue-router';\n\nconst isSaved = ref(false);\nconst showSuccess = ref(false);\nconst router = useRouter();\n\nfunction save() {\n  const newForm = {\n    title: 'ABA m\u00e5nedskontrol',\n    createdAt: new Date(),\n  };\n\n  addForm(newForm)\n    .then(() =&gt; {\n      isSaved.value = true;\n      showSuccess.value = true;\n\n      setTimeout(() =&gt; {\n        router.push('/skemaer');\n      }, 5000);\n    })\n    .catch((error) =&gt; {\n      console.error('Fejl ved gemning af skema:', error);\n    });\n}\n</code></pre> <pre><code>import { ref } from 'vue';\n\n\nconst addForm = jest.fn();\nconst push = jest.fn();\nconst router = { push };\n\n\nconst isSaved = ref(false);\nconst showSuccess = ref(false);\n\n\nfunction save() {\n  const newForm = {\n    title: 'ABA m\u00e5nedskontrol',\n    createdAt: expect.any(Date),\n  };\n\n  addForm(newForm)\n    .then(() =&gt; {\n      isSaved.value = true;\n      showSuccess.value = true;\n\n      setTimeout(() =&gt; {\n        router.push('/skemaer');\n      }, 5000);\n    })\n    .catch((error) =&gt; {\n\n    });\n}\n\ndescribe('save', () =&gt; {\n  beforeEach(() =&gt; {\n    isSaved.value = false;\n    showSuccess.value = false;\n    addForm.mockReset();\n    push.mockReset();\n  });\n\n  test('kalder addForm med korrekt data', async () =&gt; {\n    addForm.mockResolvedValueOnce();\n    save();\n    expect(addForm).toHaveBeenCalledWith(\n      expect.objectContaining({ title: 'ABA m\u00e5nedskontrol' })\n    );\n  });\n\n  test('s\u00e6tter isSaved og showSuccess til true ved succes', async () =&gt; {\n    addForm.mockResolvedValueOnce();\n    save();\n    // Vent p\u00e5 promises\n    await Promise.resolve();\n    expect(isSaved.value).toBe(true);\n    expect(showSuccess.value).toBe(true);\n  });\n\n  test('kalder router.push efter 5 sekunder', async () =&gt; {\n    jest.useFakeTimers();\n    addForm.mockResolvedValueOnce();\n    save();\n    await Promise.resolve();\n    jest.advanceTimersByTime(5000);\n    expect(router.push).toHaveBeenCalledWith('/skemaer');\n    jest.useRealTimers();\n  });\n\n  test('logger fejl ved fejl i addForm', async () =&gt; {\n    const error = new Error('Testfejl');\n    console.error = jest.fn();\n    addForm.mockRejectedValueOnce(error);\n    save();\n    // Vent p\u00e5 promises\n    await Promise.resolve();\n    expect(console.error).toHaveBeenCalledWith(\n      'Fejl ved gemning af skema:',\n      error\n    );\n  });\n});\n</code></pre> <pre><code>PASS  save.test.js\n  save\n    \u2713 kalder addForm med korrekt data\n    \u2713 s\u00e6tter isSaved og showSuccess til true ved succes\n    \u2713 kalder router.push efter 5 sekunder\n    \u2713 logger fejl ved fejl i addForm\n\nTest Suites: 1 passed, 1 total\nTests:       4 passed, 4 total\n</code></pre> <pre><code>// N\u00e5r brugeren klikker \"Gem\":\nsave();\n\n// Ved succes:\n// - isSaved.value === true\n// - showSuccess.value === true\n// - Efter 5 sekunder: router.push('/skemaer')\n</code></pre>"},{"location":"tests/#end-2-end-tests","title":"End-2-end tests","text":""},{"location":"tests/#login","title":"Login","text":"<p>Her testes der at login-flowet virker \u2013 b\u00e5de for korrekt og forkert login.</p> ForklaringTestkodeTest-output <p>Testen simulerer en bruger, der: - G\u00e5r til login siden - Indtaster email og password - Klikker \"Log ind\" - Bliver omdirigeret til skema oversigten ved succes - F\u00e5r en fejlbesked ved forkert login</p> <pre><code>describe('Login-flow', () =&gt; {\n  it('logger ind med korrekt email og password', () =&gt; {\n    cy.visit('/login');\n    cy.get('input#email').type('user@user.dk');\n    cy.get('input#password').type('hemmeligtpassword');\n    cy.get('button[type=\"submit\"]').click();\n    cy.url().should('include', '/skemaer');\n    cy.contains('Skemaer').should('be.visible');\n  });\n\n  it('viser fejlbesked ved forkert login', () =&gt; {\n    cy.visit('/login');\n    cy.get('input#email').type('forkert@dbi.dk');\n    cy.get('input#password').type('forkertkode');\n    cy.get('button[type=\"submit\"]').click();\n    cy.contains('Email eller password matcher ikke').should('be.visible');\n  });\n});\n</code></pre> <pre><code>&gt; npx cypress run\n\n  Login-flow\n    \u2713 logger ind med korrekt email og password (2s)\n    \u2713 viser fejlbesked ved forkert login (1s)\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\n</code></pre>"},{"location":"tests/#opret-nyt-skema","title":"Opret nyt skema","text":"<p>Her testes der, at en bruger kan oprette et nyt skema.</p> ForklaringTestkodeTest-output <p>Testen simulerer en bruger, der: - G\u00e5r til skema oversigten  - Klikker p\u00e5 \"Lav nyt skema\" - Udfylder navn p\u00e5 skema - Klikker \"N\u00e6ste\" - Bliver sendt videre til skabelon siden - Ser det nye skema </p> <pre><code>describe('Opret nyt skema', () =&gt; {\n  it('opretter et nyt skema fra skema-oversigten', () =&gt; {\n    // Foruds\u00e6t: Brugeren er allerede logget ind\n    cy.visit('/skemaer');\n    cy.contains('Lav nyt skema').click();\n    cy.get('input.name-input').type('Testskema E2E');\n    cy.get('button.next-btn').click();\n    cy.url().should('include', '/skemaer/skema/skabelon');\n    cy.contains('ABA m\u00e5nedskontrol').should('be.visible');\n  });\n});\n</code></pre> <pre><code>&gt; npx cypress run\n\n  Opret nyt skema\n    \u2713 opretter et nyt skema fra skema-oversigten (3s)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\n</code></pre>"}]}